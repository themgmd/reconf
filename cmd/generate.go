package cmd

import (
	"fmt"
	"go/format"
	"log"
	"os"
	"strings"

	"github.com/spf13/cobra"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"
	"gopkg.in/yaml.v3"

	"github.com/themgmd/reconf/internal/constants"
)

var (
	configDir string
	outDir    string
)

// generateCmd represents the `generate` command.
var generateCmd = &cobra.Command{
	Use:     "generate",
	Aliases: []string{"gen", "g"},
	Short:   "Generate configuration",
	Long:    "\nGenerate configuration files.",
}

// genKeysCmd represents the `generate keys` command.
var genKeysCmd = &cobra.Command{
	Use:     "keys",
	Aliases: []string{"k"},
	Short:   "Create a new project via interactive UI",
	Long:    "\nCreate a new project via interactive UI.",
	RunE:    generateKeysCmd,
}

// genTemplateCmd represents the `generate template` command.
var genTemplateCmd = &cobra.Command{
	Use:     "template",
	Aliases: []string{"t"},
	Short:   "Create a new project via interactive UI",
	Long:    "\nCreate a new project via interactive UI.",
	RunE:    generateTemplateCmd,
}

func init() {
	rootCmd.AddCommand(generateCmd)

	generateCmd.AddCommand(genKeysCmd)
	genKeysCmd.Flags().StringVarP(
		&configDir,
		"dir", "d", "./build/configs",
		"set directory for configs files",
	)
	genKeysCmd.Flags().StringVarP(
		&outDir,
		"out", "o", "./internal/configs",
		"set output directory for configs keys",
	)

	generateCmd.AddCommand(genTemplateCmd)
	genTemplateCmd.Flags().StringVarP(
		&configDir,
		"dir", "d", "./build/configs",
		"set directory for configs files",
	)
}

// generateKeysCmd generate file with configs variables keys
func generateKeysCmd(*cobra.Command, []string) error {
	filename := fmt.Sprintf("%s/values.yaml", configDir)
	data, err := os.ReadFile(filename)
	if err != nil {
		log.Fatalf("failed to read yaml: %v", err)
	}

	var content map[string]interface{}
	if err := yaml.Unmarshal(data, &content); err != nil {
		log.Fatalf("failed to unmarshal yaml: %v", err)
	}

	configMap, ok := content["config"].(map[string]interface{})
	if !ok {
		log.Fatalf("configs block not found or invalid")
	}

	secretMap, ok := content["secret"].(map[string]interface{})
	if !ok {
		log.Fatalf("secret block not found or invalid")
	}

	var builder strings.Builder
	builder.WriteString("package configs\n\n")
	builder.WriteString("// Code generated by generator; DO NOT EDIT.\n\n")
	builder.WriteString("const (\n")

	for key := range configMap {
		constName := toCamelCase(key)
		builder.WriteString(fmt.Sprintf("\t%s = \"%s\"\n", constName, key))
	}

	builder.WriteString("\n")

	for key := range secretMap {
		constName := toCamelCase(key)
		builder.WriteString(fmt.Sprintf("\t%s = \"%s\"\n", constName, key))
	}

	builder.WriteString(")\n\n")

	src := builder.String()

	formattedSrc, err := format.Source([]byte(src))
	if err != nil {
		log.Fatalf("failed to format source: %v", err)
	}

	// create output directory if not exists
	err = os.MkdirAll(outDir, 0755)
	if err != nil {
		log.Fatalf("failed to create output directory: %v", err)
	}

	filename = fmt.Sprintf("%s/config_gen.go", outDir)
	err = os.WriteFile(filename, formattedSrc, 0644)
	if err != nil {
		log.Fatalf("failed to write generated file: %v", err)
	}

	fmt.Println("Code generated in config_gen.go")
	return nil
}

func generateTemplateCmd(*cobra.Command, []string) error {
	err := os.MkdirAll(configDir, 0755)
	if err != nil {
		log.Fatalf("failed to create configs directory: %v", err)
	}

	filename := fmt.Sprintf("%s/values.yaml", configDir)
	content := constants.DefaultConfigTemplate
	err = os.WriteFile(filename, []byte(content), 0644)
	if err != nil {
		log.Fatalf("failed to write template default file: %v", err)
	}

	// write environment configs override files
	envs := []string{constants.EnvDev, constants.EnvStg, constants.EnvProd}
	for _, env := range envs {
		lowerEnv := strings.ToLower(env)
		filename = fmt.Sprintf("%s/values_%s.yaml", configDir, lowerEnv)
		content = constants.EnvironmentConfigTemplate(lowerEnv)
		err = os.WriteFile(filename, []byte(content), 0644)
		if err != nil {
			log.Fatalf("failed to write template %s file: %v", lowerEnv, err)
		}
	}

	return nil
}

func toCamelCase(s string) string {
	parts := strings.Split(s, "_")
	for i := range parts {
		parts[i] = cases.Title(language.English).String(parts[i])
	}
	return strings.Join(parts, "")
}
