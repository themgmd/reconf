package main

import (
	"flag"
	"fmt"
	"go/format"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"
	"gopkg.in/yaml.v3"
	"log"
	"os"
	"strings"
)

var (
	configDir  string
	configFile string
	outDir     string
)

func init() {
	flag.StringVar(&configDir, "cdir", "./build/configs", "the path to look for")
	flag.StringVar(&configFile, "cfile", "values.yaml", "the file to look for")
	flag.StringVar(&outDir, "out", "./internal/config", "the output path")
}

func main() {
	filename := fmt.Sprintf("%s/%s", configDir, configFile)
	data, err := os.ReadFile(filename)
	if err != nil {
		log.Fatalf("failed to read yaml: %v", err)
	}

	var content map[string]interface{}
	if err := yaml.Unmarshal(data, &content); err != nil {
		log.Fatalf("failed to unmarshal yaml: %v", err)
	}

	configMap, ok := content["config"].(map[string]interface{})
	if !ok {
		log.Fatalf("config block not found or invalid")
	}

	secretMap, ok := content["secret"].(map[string]interface{})
	if !ok {
		log.Fatalf("secret block not found or invalid")
	}

	var builder strings.Builder
	builder.WriteString("package config\n\n")
	builder.WriteString("// Code generated by generator; DO NOT EDIT.\n\n")
	builder.WriteString("const (\n")

	for key := range configMap {
		constName := toCamelCase(key)
		builder.WriteString(fmt.Sprintf("\t%s = \"%s\"\n", constName, key))
	}

	builder.WriteString("\n")

	for key := range secretMap {
		constName := toCamelCase(key)
		builder.WriteString(fmt.Sprintf("\t%s = \"%s\"\n", constName, key))
	}

	builder.WriteString(")\n\n")

	src := builder.String()

	formattedSrc, err := format.Source([]byte(src))
	if err != nil {
		log.Fatalf("failed to format source: %v", err)
	}

	filename = fmt.Sprintf("%s/config_gen.go", outDir)
	err = os.WriteFile(filename, formattedSrc, 0644)
	if err != nil {
		log.Fatalf("failed to write generated file: %v", err)
	}

	fmt.Println("Code generated in config_gen.go")
}

func toCamelCase(s string) string {
	parts := strings.Split(s, "_")
	for i := range parts {
		parts[i] = cases.Title(language.English).String(parts[i])
	}
	return strings.Join(parts, "")
}
